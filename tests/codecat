/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:33 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:34 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#ifndef _GET_NEXT_LINE_H
# define _GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 32
# endif

typedef struct		s_bblock
{
	struct s_bblock	*next;
	char			data[BUFFER_SIZE];
}					t_bblock;

typedef struct
{
	int				content_size;
	int				buff_size;
	t_bblock		block;
}					t_buff;

int					get_next_line(int fd, char **line);

t_buff				*create_buffer();
int					write_char_buffer(t_buff *buff, char c);
char				*merge_buffer(t_buff *buff);
void				destroy_buffer(t_buff *buff);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:18 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:19 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <stdlib.h>

#include "get_next_line.h"

t_buff			*create_buffer(void)
{
	t_buff *buff;

	buff = malloc(sizeof(t_buff));
	if (buff != NULL)
	{
		buff->content_size = 0;
		buff->buff_size = BUFFER_SIZE;
		buff->block.next = NULL;
	}
	return (buff);
}

static t_bblock	*get_or_extend_buffer(t_buff *buff, size_t index)
{
	t_bblock	*previous;
	size_t		i;

	i = 0;
	previous = &(buff->block);
	while (previous->next != NULL && i < index)
	{
		previous = previous->next;
		++i;
	}
	if (i == index)
		return (previous);
	previous->next = malloc(sizeof(t_bblock));
	previous->next->next = NULL;
	return (previous->next);
}

int				write_char_buffer(t_buff *buff, char c)
{
	const int	index = buff->content_size / buff->buff_size;
	t_bblock	*elem;

	elem = get_or_extend_buffer(buff, index);
	if (elem == NULL)
		return (0);
	((char *)elem->data)[buff->content_size % buff->buff_size] = c;
	buff->content_size++;
	return (1);
}

char			*merge_buffer(t_buff *buff)
{
	char		*merged;
	int			index;
	t_bblock	*block;
	int			last_block;

	if (!write_char_buffer(buff, 0))
		return (NULL);
	merged = malloc(buff->content_size + 1);
	if (merged == NULL)
		return (NULL);
	block = &(buff->block);
	last_block = 0;
	index = 0;
	while (index < buff->content_size)
	{
		if (index / buff->buff_size != last_block)
		{
			block = block->next;
			++last_block;
		}
		merged[index] = ((char *)block->data)[index % buff->buff_size];
		++index;
	}
	merged[index] = 0;
	return (merged);
}

void			destroy_buffer(t_buff *buff)
{
	t_bblock *next_block;
	t_bblock *tmp;

	next_block = buff->block.next;
	while (next_block != NULL)
	{
		tmp = next_block;
		next_block = next_block->next;
		free(tmp);
	}
	free(buff);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: clsaad <clsaad@student.42lyon.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/25 13:49:13 by clsaad            #+#    #+#             */
/*   Updated: 2020/11/25 13:49:14 by clsaad           ###   ########lyon.fr   */
/*                                                                            */
/* ************************************************************************** */

#include <stddef.h>
#include <unistd.h>

#include "get_next_line.h"

/*
** Reads the next unsigned char from fd. This method uses an internal static
** buffer to store the chars it reads from fd. The internal buffer size
** is BUFFER_SIZE.
**
** @returns the next unsigned char from fd if any; -1 if it reaches the end of
** file of the fd; -2 if an error occured.
**
** @see man read(2)
** @see BUFFER_SIZE
*/

int		read_char(int fd)
{
	static char		buffer[BUFFER_SIZE];
	static ssize_t	buffer_size = 0;
	unsigned char	c;
	ssize_t			i;

	if (buffer_size == 0)
	{
		buffer_size = read(fd, buffer, BUFFER_SIZE);
		if (buffer_size == 0)
			return (-1);
		if (buffer_size == -1)
			return (-2);
	}
	c = (unsigned char)(buffer[0]);
	i = 0;
	--buffer_size;
	while (i < buffer_size)
	{
		buffer[i] = buffer[i + 1];
		++i;
	}
	return ((int)c);
}

int		get_next_line(int fd, char **line)
{
	t_buff	*content;
	int		c;
	char	*result;

	content = create_buffer();
	if (content == NULL)
		return (-1);
	while ((c = read_char(fd)) >= 0)
	{
		if (c == '\n')
			break ;
		if (!write_char_buffer(content, c))
		{
			c = -2;
			break ;
		}
	}
	if ((result = merge_buffer(content)) == NULL)
		c = -2;
	destroy_buffer(content);
	if (c != '\n')
		return (c + 1);
	*line = result;
	return (1);
}
*//======== END OF FILE ========\\*
jgiotjokdnbkdflnvofjdk

REAL EOF

